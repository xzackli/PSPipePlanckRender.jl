var documenterSearchIndex = {"docs":
[{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/src/slurmgen.jl\"","category":"page"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"# all examples are run on an example global.toml and downsized maps.\nARGS = [\"example.toml\"]","category":"page"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"configfile = ARGS[1]","category":"page"},{"location":"slurmgen/#SLURM-Commands-for-Spectra-(slurmgen.jl)","page":"slurmgen.jl","title":"SLURM Commands for Spectra (slurmgen.jl)","text":"","category":"section"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"This command generates SLURM commands that executes rawspectra.jl on all the pairs of maps in the config.","category":"page"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"# this file just prints out the SLURM commands required to compute the spectra\nusing TOML\nconfig = TOML.parsefile(configfile)","category":"page"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"Let's generate the commands we need for likelihood spectra.","category":"page"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"mapids = [k for k in keys(config[\"map\"])]\nrun = \"sbatch scripts/4core1hr.cmd\"\nfor i in 1:length(mapids)\n    for j in i:length(mapids)\n        println(\"$(run) \\\"julia src/rawspectra.jl global.toml $(mapids[i]) $(mapids[j])\\\"\")\n    end\nend","category":"page"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"I just paste these in and wait a few hours. The resulting spectra are deposited in the scratch dir in the config.","category":"page"},{"location":"slurmgen/#Fit-Noise-Model","page":"slurmgen.jl","title":"Fit Noise Model","text":"","category":"section"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"These SLURM commands fit the raw spectra with the camspec noise model.","category":"page"},{"location":"slurmgen/","page":"slurmgen.jl","title":"slurmgen.jl","text":"# loop over freqs and noise channels\nfor freq in (\"100\", \"143\", \"217\")\n    for spec in (\"TT\", \"EE\")\n        println(\"$(run) \\\"julia src/fitnoisemodel.jl global.toml $(freq) $(spec)\\\"\")\n    end\nend","category":"page"},{"location":"PSPipePlanckRender/","page":"-","title":"-","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/src/PSPipePlanckRender.jl\"","category":"page"},{"location":"PSPipePlanckRender/","page":"-","title":"-","text":"module PSPipePlanckRender\n\n\nend","category":"page"},{"location":"binning/","page":"-","title":"-","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/src/binning.jl\"","category":"page"},{"location":"binning/","page":"-","title":"-","text":"# all examples are run on an example global.toml and downsized maps.\nARGS = [\"example.toml\"]","category":"page"},{"location":"binning/","page":"-","title":"-","text":"configfile = ARGS[1]\n\n# get modules and utility functions\nusing Plots\nusing TOML\nusing Healpix\ninclude(\"util.jl\")\n\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nlmax = nside2lmax(nside)\n\npl = PlanckReferenceCov(joinpath(config[\"dir\"][\"scratch\"], \"plicref\"))\n\n# read binning scheme\nbinfile = joinpath(config[\"dir\"][\"pspipe_project\"], \"input\", \"binused.dat\")\nP, lb = util_planck_binning(binfile; lmax=lmax);\n\n#\nfreq1, freq2 = \"100\", \"100\"\nWl = util_planck_beam_Wl(freq1, \"hm1\", freq2, \"hm2\", :EE, :EE;\n    lmax=lmax, beamdir=config[\"dir\"][\"beam\"])\nplot(Wl, yaxis=:log10, label=\"\\$B_{\\\\ell}\\$\")\n\n#\nrun_name = config[\"general\"][\"name\"]\nmapids = [k for k in keys(config[\"map\"])]\nspectrapath = joinpath(config[\"dir\"][\"scratch\"], \"rawspectra\")\n\nmapid1 = \"P$(freq1)hm1\"\nmapid2 = \"P$(freq2)hm2\"\nspec = DataFrame(CSV.File(joinpath(spectrapath,\"$(run_name)_$(mapid1)x$(mapid2).csv\")))\nplot(spec.ell, spec.ell.^2 .* spec.EE, label=\"$(run_name)_$(mapid1)x$(mapid2)\",\n    xlabel=\"multipole moment\", ylabel=\"\\$\\\\ell^2 C_{\\\\ell}^{EE}\\$\", xlim=(0,2nside))\n\n#\nlbref, cbref, err_ref, _ = extract_spec_and_cov(pl, \"EE_$(freq1)x$(freq2)\")\n\n#\ncl = SpectralVector(copy(spec.EE))\nthis_lmax = max(lastindex(cl), lastindex(Wl))\npixwinT, pixwinP = pixwin(nside; pol=true)\ncl[0:this_lmax] ./= Wl[0:this_lmax] .* pixwinP[1:(this_lmax+1)].^2\ncl[0:1] .= 0.0\ncb = P * parent(cl)\nplanck_bin_choice = findfirst(lb .‚â• lbref[1]):findlast(lb .‚â§ lbref[end])\n\nnside_cut = 1:length(planck_bin_choice)\nplot(lb[planck_bin_choice], (cb[planck_bin_choice] .- cbref[nside_cut]) ./ err_ref[nside_cut],\n    ylim=(-2,2), label=label=\"$(run_name)_$(mapid1)x$(mapid2)\")","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/src/fitnoisemodel.jl\"","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"# the example command line input for this script\nARGS = [\"example.toml\", \"100\", \"EE\", \"--plot\"]","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"configfile, freq, spec = ARGS","category":"page"},{"location":"fitnoisemodel/#fitnoisemodel","page":"fitnoisemodel.jl","title":"Fit Noise Model (fitnoisemodel.jl)","text":"","category":"section"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"# setup data\nusing Plots\nusing TOML\nusing BlackBoxOptim\ninclude(\"util.jl\")\n\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nrun_name = config[\"general\"][\"name\"]\nspectrapath = joinpath(config[\"dir\"][\"scratch\"], \"rawspectra\")\nXY = Symbol(spec)\nlmax = min(2508,nside2lmax(nside))","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"Next, we check to see if we need to render plots for the Documentation.","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"if \"--plot\" ‚àâ ARGS\n    Plots.plot(args...; kwargs...) = nothing\n    Plots.plot!(args...; kwargs...) = nothing\nend","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"We read in the raw spectra generated from rawspectra.jl.","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"Cl11 = DataFrame(CSV.File(joinpath(spectrapath,\"$(run_name)_P$(freq)hm1xP$(freq)hm1.csv\")));\nCl12 = DataFrame(CSV.File(joinpath(spectrapath,\"$(run_name)_P$(freq)hm1xP$(freq)hm2.csv\")));\nCl22 = DataFrame(CSV.File(joinpath(spectrapath,\"$(run_name)_P$(freq)hm2xP$(freq)hm2.csv\")));\n\ntruncate(vec::Vector, lmax) = SpectralVector(vec[firstindex(vec):(lmax+1)])\ntruncate(vec::SpectralVector, lmax) = vec[IdentityRange(firstindex(vec):lmax)]\n\ncl11 = truncate(Cl11[!,XY], lmax)\ncl12 = truncate(Cl12[!,XY], lmax)\ncl22 = truncate(Cl22[!,XY], lmax)\n\nWl11 = util_planck_beam_Wl(freq, \"hm1\", freq, \"hm1\", XY, XY;\n    lmax=lmax, beamdir=config[\"dir\"][\"beam\"])\nWl12 = util_planck_beam_Wl(freq, \"hm1\", freq, \"hm2\", XY, XY;\n    lmax=lmax, beamdir=config[\"dir\"][\"beam\"])\nWl22 = util_planck_beam_Wl(freq, \"hm2\", freq, \"hm2\", XY, XY;\n    lmax=lmax, beamdir=config[\"dir\"][\"beam\"])\n\nWl11, Wl12, Wl22 = map(v->truncate(v,lmax), (Wl11, Wl12, Wl22))\n\ncl = cl12 ./ Wl12\nnl1 = (cl11 ./ Wl11 .- cl) .* Wl11\nnl2 = (cl22 ./ Wl22  .- cl) .* Wl22;\n\nell = eachindex(cl)\nplot(ell, ell.^2 .* cl12, label=\"unbeamed $(run_name) $(freq) $(spec)\",\n    xlabel=\"multipole moment\", ylabel=\"\\$\\\\ell^2 C_{\\\\ell}^{$spec}\\$\", xlim=(0,lmax))","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"@. camspec_model(‚Ñì, Œ±) =\n    Œ±[1] * (100. / ‚Ñì)^Œ±[2] + Œ±[3] * (‚Ñì / 1000.)^Œ±[4] / ( 1 + (‚Ñì / Œ±[5])^Œ±[6] )^Œ±[7]","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"function fit_bb_model(model, p0, xl, yl, signal; kwargs...)\n    lower = map(x -> x-0.9abs(x), p0)\n    upper = map(x -> x+0.9abs(x), p0)\n    like(Œ±) = (sum((2 .* xl .+ 1) ./ (model(xl, p0).^2 .+ signal.^2) .* (model(xl, Œ±) .- yl).^2))\n    println(\"starting opt \", like(p0))\n    res = bboptimize(like; SearchRange=map((i,j)->(i,j), lower, upper), NumDimensions = length(p0),\n        MaxFuncEvals=50_000, TraceInterval=20)\n    return best_candidate(res)\nend","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"p0_1 = readdlm(joinpath(config[\"dir\"][\"pspipe_project\"], \"output\",\n        \"planck_noise_coeffs\", \"$(freq)_hm1_$(spec)_coeff.dat\"))[:,1]\np0_2 = readdlm(joinpath(config[\"dir\"][\"pspipe_project\"], \"output\",\n        \"planck_noise_coeffs\", \"$(freq)_hm2_$(spec)_coeff.dat\"))[:,1]","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"min_ell_ind = 31 # lmin=30\npfit_1 = fit_bb_model(camspec_model, p0_1,\n    parent(ell)[min_ell_ind:end], parent(nl1)[min_ell_ind:end], parent(cl)[min_ell_ind:end])\npfit_2 = fit_bb_model(camspec_model, p0_2,\n    parent(ell)[min_ell_ind:end], parent(nl2)[min_ell_ind:end], parent(cl)[min_ell_ind:end])","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"mean(x) = sum(x) / length(x)\nplot((nl1), alpha=0.5, label=\"nl hm1\")\nplot!(2:lmax, [camspec_model(‚Ñì, p0_1) for ‚Ñì in 2:lmax], ylim=(0.0, 4mean(abs.(nl1))), label=\"initial model\")\nplot!(2:lmax, [camspec_model(‚Ñì, pfit_1) for ‚Ñì in 2:lmax], label=\"fitted model\", linestyle=:dash)","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"plot((nl2), alpha=0.5, label=\"nl hm2\")\nplot!(2:lmax, [camspec_model(‚Ñì, p0_2) for ‚Ñì in 2:lmax], ylim=(0.0, 2mean(nl2)), label=\"initial model\")\nplot!(2:lmax, [camspec_model(‚Ñì, pfit_2) for ‚Ñì in 2:lmax], ylim=(0.0, 2mean(nl2)), label=\"fitted model\", linestyle=:dash)","category":"page"},{"location":"fitnoisemodel/","page":"fitnoisemodel.jl","title":"fitnoisemodel.jl","text":"coefficientpath = joinpath(config[\"dir\"][\"scratch\"], \"noise_model_coeffs\")\nmkpath(coefficientpath)\n\nopen(joinpath(coefficientpath, \"$(run_name)_$(freq)_$(spec)_hm1.dat\"), \"w\") do io\n   writedlm(io, pfit_1)\nend\nopen(joinpath(coefficientpath, \"$(run_name)_$(freq)_$(spec)_hm2.dat\"), \"w\") do io\n   writedlm(io, pfit_2)\nend","category":"page"},{"location":"pipeline/","page":"Pipeline","title":"Pipeline","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/docs/src/pipeline.md\"","category":"page"},{"location":"pipeline/#Pipeline","page":"Pipeline","title":"Pipeline","text":"","category":"section"},{"location":"pipeline/","page":"Pipeline","title":"Pipeline","text":"The following file lists the shell commands that comprise the pipeline.","category":"page"},{"location":"pipeline/","page":"Pipeline","title":"Pipeline","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">julia src/setup.jl global.toml\n</code></pre>","category":"page"},{"location":"pipeline/","page":"Pipeline","title":"Pipeline","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">sbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P100hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P143hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P143hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P217hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm1 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P143hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P143hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P217hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm1 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm2 P143hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm2 P217hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm2 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P143hm2 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P217hm1 P217hm1\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P217hm1 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P217hm1 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm2 P100hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P100hm2 P217hm2\"\nsbatch scripts/4core1hr.cmd \"julia src/rawspectra.jl global.toml P217hm2 P217hm2\"\n</code></pre>","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/src/rawspectra.jl\"","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"# the example command line input for this script\nARGS = [\"example.toml\", \"P143hm1\", \"P143hm2\", \"--plot\"]","category":"page"},{"location":"rawspectra/#rawspectra","page":"rawspectra.jl","title":"Raw Spectra (rawspectra.jl)","text":"","category":"section"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"The first step in the pipeline is simply to compute the pseudo-spectrum between the maps X and Y. We define the pseudo-spectrum widetildeC_ell as the result of the estimator on spherical harmonic coefficients of the masked sky,","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"widetildeC_ell = frac12ell+1 sum_m a^iX_ell m a^jY_ell m","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"Since we mask the galaxy and point sources, this is a biased estimate of the underlying power spectrum. The mask couples modes together, and also removes power from parts of the sky. This coupling is described by a linear operator mathbfM, the mode-coupling matrix. For more details on spectra and mode-coupling, please refer to the documentation for PowerSpectra.jl. If this matrix is known, then one can perform a linear solve to obtain an unbiased estimate of the underlying power spectrum C_ell,","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"langlewidetildeC_ellrangle =\nmathbfM^XY(ij)_ell_1 ell_2 langle C_ell rangle","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"This script performs this linear solve, without accounting for beams. The noise spectra are estimated from the difference of auto- and cross-spectra, The command-line syntax for using this component to compute mode-coupled spectra is","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia rawspectra.jl global.toml [map1] [map2]</code></pre>","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"[map1] and [map2] must be names of maps described in global.toml.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"This page shows the results of running the command","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia src/rawspectra.jl example.toml P143hm1 P143hm2</code></pre>","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"The first step is just to unpack the command-line arguments, which consist of the TOML config file and the map names, which we term channels 1 and 2.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"configfile, mapid1, mapid2 = ARGS","category":"page"},{"location":"rawspectra/#File-Loading-and-Cleanup","page":"rawspectra.jl","title":"File Loading and Cleanup","text":"","category":"section"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"We start by loading the necessary packages.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"using TOML\nusing Healpix\nusing PowerSpectra\nusing Plots","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"config = TOML.parsefile(configfile)","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"Next, we check to see if we need to render plots for the Documentation.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"if \"--plot\" ‚àâ ARGS\n    Plots.plot(args...; kwargs...) = nothing\n    Plots.plot!(args...; kwargs...) = nothing\nend","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"For both input channels, we need to do some pre-processing steps.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"We first load in the I, Q, and U Stokes vectors, which are FITS columns 1, 2, and 3 in the Planck map files. These must be converted from nested to ring ordered, to perform SHTs.\nWe read in the corresponding masks in temperature and polarization.\nWe zero the missing pixels in the maps, and also zero the corresponding pixels in the masks.\nWe convert from mathrmK_mathrmCMB to mu mathrmK_mathrmCMB.\nApply a small polarization amplitude adjustment, listed as poleff in the config.\nWe also remove some noisy pixels with mathrmsigma(Q)  10^6mumathrmK^2 or mathrmsigma(U)  10^6mumathrmK^2, or if they are negative. This removes a handful of pixels in the 2018 maps at 100 GHz which interfere with covariance estimation.\nEstimate and subtract the pseudo-monopole and pseudo-dipole.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"\"\"\"Return (polarized map, maskT, maskP) given a config and map identifier\"\"\"\nfunction load_maps_and_masks(config, mapid, maptype=Float64)\n    # read map file\n    println(\"Reading \", config[\"map\"][mapid])\n    mapfile = joinpath(config[\"dir\"][\"map\"], config[\"map\"][mapid])\n    polmap = PolarizedMap(\n        nest2ring(readMapFromFITS(mapfile, 1, maptype)),  # I\n        nest2ring(readMapFromFITS(mapfile, 2, maptype)),  # Q\n        nest2ring(readMapFromFITS(mapfile, 3, maptype)))  # U\n\n    # read maskT and maskP\n    maskfileT = joinpath(config[\"dir\"][\"mask\"], config[\"maskT\"][mapid])\n    maskfileP = joinpath(config[\"dir\"][\"mask\"], config[\"maskP\"][mapid])\n    maskT = readMapFromFITS(maskfileT, 1, maptype)\n    maskP = readMapFromFITS(maskfileP, 1, maptype)\n\n    # read Q and U pixel variances, and convert to ŒºK\n    covQQ = nest2ring(readMapFromFITS(mapfile, 8, maptype)) .* 1e12\n    covUU = nest2ring(readMapFromFITS(mapfile, 10, maptype)) .* 1e12\n\n    # go from KCMB to ŒºKCMB, and apply polarization factor\n    poleff = config[\"poleff\"][mapid]\n    scale!(polmap, 1e6, 1e6 * poleff)  # apply 1e6 to (I) and 1e6 * poleff to (Q,U)\n\n    # identify missing pixels and also pixels with crazy variances\n    missing_pix = (polmap.i .< -1.6e30)\n    missing_pix .*= (covQQ .> 1e6) .| (covUU .> 1e6) .| (covQQ .< 0.0) .| (covUU .< 0.0)\n    allowed = (~).(missing_pix)\n\n    # apply the missing pixels to the map and mask for T/P\n    mask!(polmap, allowed, allowed)\n    mask!(maskT, allowed)\n    mask!(maskP, allowed)\n\n    # fit and remove pseudo-monopole/dipole in I\n    monopole, dipole = fitdipole(polmap.i * maskT)\n    subtract_monopole_dipole!(polmap.i, monopole, dipole)\n\n    return polmap, maskT, maskP\nend","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"We'll use this function for the half-missions involved here.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"m‚ÇÅ, maskT‚ÇÅ, maskP‚ÇÅ = load_maps_and_masks(config, mapid1)\nm‚ÇÇ, maskT‚ÇÇ, maskP‚ÇÇ = load_maps_and_masks(config, mapid2)\nplot(m‚ÇÅ.i, clim=(-200,200))  # plot the intensity map","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"plot(maskT‚ÇÅ)  # show the temperature mask","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"run_name = config[\"general\"][\"name\"]\nfunction save_if_needed(mapobj, mapfile)\n    if isfile(mapfile) == false\n        saveToFITS(mapobj, mapfile)\n    end\nend\n\nsave_if_needed(maskT‚ÇÅ, joinpath(config[\"dir\"][\"mask\"], \"$(run_name)_$(mapid1)_maskT.fits\"))\nsave_if_needed(maskP‚ÇÅ, joinpath(config[\"dir\"][\"mask\"], \"$(run_name)_$(mapid1)_maskP.fits\"))\nsave_if_needed(maskT‚ÇÇ, joinpath(config[\"dir\"][\"mask\"], \"$(run_name)_$(mapid2)_maskT.fits\"))\nsave_if_needed(maskP‚ÇÇ, joinpath(config[\"dir\"][\"mask\"], \"$(run_name)_$(mapid2)_maskP.fits\"))","category":"page"},{"location":"rawspectra/#Computing-Spectra-and-Saving","page":"rawspectra.jl","title":"Computing Spectra and Saving","text":"","category":"section"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"Once you have cleaned up maps and masks, you compute the calculation is described in PowerSpectra - Mode Coupling. That package has a utility function master that performs the full MASTER calculation on two IQU maps with associated masks.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"# do the mode coupling on all T, E, and B spectra\nCl = master(m‚ÇÅ, maskT‚ÇÅ, maskP‚ÇÅ,\n            m‚ÇÇ, maskT‚ÇÇ, maskP‚ÇÇ)\nnside = maskT‚ÇÅ.resolution.nside  # get the resolution from any of the maps\nlmax = nside2lmax(nside)\nprintln(keys(Cl))  # check what spectra were computed","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"The PowerSpectra.jl package has the Planck bestfit theory and beams as utility functions, for demo and testing purposes. We can use it that for plotting here.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"spec = :TT\nWl = PowerSpectra.planck_beam_Wl(\"143\", \"hm1\", \"143\", \"hm2\", spec, spec; lmax=lmax)\npixwinT = SpectralVector(pixwin(nside)[1:(lmax+1)])\nell = eachindex(Wl)\nprefactor = ell .* (ell .+ 1) ./ (2œÄ)\nplot( prefactor .*  Cl[spec] ./ (Wl .* pixwinT.^2),\n    label=\"\\$D_{\\\\ell}\\$\", xlim=(0,2nside))\ntheory = PowerSpectra.planck_theory_Dl()\nplot!(theory[spec], label=\"theory $(spec)\")","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"Now we save our spectra.","category":"page"},{"location":"rawspectra/","page":"rawspectra.jl","title":"rawspectra.jl","text":"# set up spectra path\nusing CSV, DataFrames\nspectrapath = joinpath(config[\"dir\"][\"scratch\"], \"rawspectra\")\nmkpath(spectrapath)\n\n# assemble a table with the ells and spectra\ndf = DataFrame()\ndf[!,:ell] = ell\nfor spec in keys(Cl)\n    df[!,spec] = parent(Cl[spec])\nend\n\nCSV.write(joinpath(spectrapath, \"$(run_name)_$(mapid1)x$(mapid2).csv\"), df)","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/src/signalsim.jl\"","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"# the example command line input for this script\nARGS = [\"example.toml\",  \"143\", \"143\", \"EE\", \"--plot\"]","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"configfile, freq1, freq2, spec = ARGS","category":"page"},{"location":"signalsim/#Signal-Sims-(signalsim.jl)","page":"signalsim.jl","title":"Signal Sims (signalsim.jl)","text":"","category":"section"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"This script runs signal simulations.","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"using TOML\nusing Plots\nusing Healpix\nusing JLD2, UUIDs  # for saving sim arrays\ninclude(\"util.jl\")\n\nconfig = TOML.parsefile(configfile)\nnside = config[\"general\"][\"nside\"]\nrun_name = config[\"general\"][\"name\"]\nspectrapath = joinpath(config[\"dir\"][\"scratch\"], \"rawspectra\")\nlmax = nside2lmax(nside)\nlmax_planck = min(2508, lmax)\nsplits = \"1\", \"2\"  # planck never uses any other splits","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"signal11, th = signal_and_theory(freq1, freq1, config)\nsignal12, th = signal_and_theory(freq1, freq2, config)\nsignal22, th = signal_and_theory(freq2, freq2, config)\nsignal = Dict((\"1\", \"1\") => signal11, (\"1\", \"2\") => signal12, (\"2\", \"2\") => signal22)\n\nùêÇ = zeros(2, 2, lmax+1)\nX, Y = spec\ninds = 1:(lmax_planck+1)\nùêÇ[1,1,inds] .= signal[splits[1], splits[1]][X * X][inds]\nùêÇ[1,2,inds] .= signal[splits[1], splits[2]][X * Y][inds]\nùêÇ[2,1,inds] .= signal[splits[1], splits[2]][X * Y][inds]\nùêÇ[2,2,inds] .= signal[splits[2], splits[2]][Y * Y][inds];\nnothing #hide","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"Next, we generate the mode-coupling matrix.","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"m1 = PolarizedMap{Float64, RingOrder}(nside)\nm2 = PolarizedMap{Float64, RingOrder}(nside)\na1 = [Alm(lmax, lmax) for i in 1:3]\na2 = [Alm(lmax, lmax) for i in 1:3]\n\nX, Y = Symbol(spec[1]), Symbol(spec[2])\nrun_name = config[\"general\"][\"name\"]\nmasktype1 = (X == :T) ? \"T\" : \"P\"\nmasktype2 = (Y == :T) ? \"T\" : \"P\"\nmapid1 = \"P$(freq1)hm$(splits[1])\"\nmapid2 = \"P$(freq2)hm$(splits[2])\"\n\nmaskfile1 = joinpath(config[\"dir\"][\"mask\"], \"$(run_name)_$(mapid1)_mask$(masktype1).fits\")\nmaskfile2 = joinpath(config[\"dir\"][\"mask\"], \"$(run_name)_$(mapid2)_mask$(masktype2).fits\")\nmask1 = readMapFromFITS(maskfile1, 1, Float64)\nmask2 = readMapFromFITS(maskfile2, 1, Float64)\n\nif spec == \"EE\"\n    @time M = mcm(:EE_BB, map2alm(mask1), map2alm(mask2))\nelse\n    @time M = mcm(Symbol(X,Y), map2alm(mask1), map2alm(mask2))\nend","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"\"\"\"\n    channelindex(s)\n\nConvert string/char T,E,B => 1,2,3","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"\"\"\" function channelindex(s)     s = string(s)     if s == \"T\"         return 1     elseif s == \"E\"         return 2     elseif s == \"B\"         return 3     end     throw(ArgumentError(\"unknown spectrum\")) end","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"function sim_iteration(ùêÇ, m1, m2, a1, a2, M, spec::String)     # get indices of the spectrum     c‚ÇÅ, c‚ÇÇ = channelindex(spec[1]), channelindex(spec[2])","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"# zero out alms\nfor i in 1:3\n    fill!(a1[i].alm, 0.0)\n    fill!(a2[i].alm, 0.0)\nend\n\n# synthesize polarized spectrum into m1\nsynalm!(ùêÇ, [a1[c‚ÇÅ], a2[c‚ÇÇ]])\nalm2map!(a1, m1)\nalm2map!(a2, m2)\n\n# same signal, but different masks\nmask!(m1, mask1, mask1)\nmask!(m2, mask2, mask2)\n\n# subtract monopole if TT\nif spec == \"TT\"\n    monopole, dipole = fitdipole(m1.i * mask1)\n    subtract_monopole_dipole!(m1.i, monopole, dipole)\n    monopole, dipole = fitdipole(m2.i * mask2)\n    subtract_monopole_dipole!(m2.i, monopole, dipole)\nend\n\n# apply pixel weights and then map2alm\nHealpix.applyfullweights!(m1)\nHealpix.applyfullweights!(m2)\nmap2alm!(m1, a1; niter=0)\nmap2alm!(m2, a2; niter=0)\n\nif spec == \"EE\"\n    pCl_EE = SpectralVector(alm2cl(a1[c‚ÇÅ], a2[c‚ÇÇ]))\n    pCl_BB = SpectralVector(zeros(length(pCl_EE)))\n    @spectra Cl_EE, Cl_BB = M \\ [pCl_EE; pCl_BB]\n    return Cl_EE\nend\n\n# otherwise easy mode coupling\npCl_XY = SpectralVector(alm2cl(a1[c‚ÇÅ], a2[c‚ÇÇ]))\nreturn M \\ pCl_XY","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"end","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"@example signalsim if \"‚Äìplot\" in ARGS     @time simEE = simiteration(ùêÇ, m1, m2, a1, a2, M, \"EE\")     plot(simEE .* eachindex(simEE).^2, label=\"sim\")     plot!(signal12[\"EE\"] .* eachindex(0:lmaxplanck).^2, xlim=(0,lmax_planck), label=\"input\") end","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"@example signalsim simpath = joinpath(config[\"dir\"][\"scratch\"], \"signalsims\",     \"(freq1)_(freq2)_spec\") mkpath(simpath)","category":"page"},{"location":"signalsim/","page":"signalsim.jl","title":"signalsim.jl","text":"nsims = 5000 for simindex in 1:nsims     @time cl = simiteration(ùêÇ, m1, m2, a1, a2, M, spec)     @save \"(simpath)(uuid4()).jld2\" cl=cl end ```","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/docs/src/index.md\"","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a Simons Observatory pipeline for computing the spectra and covariances of the Planck 2018 high-ell likelihood. Default settings have been chosen to reproduce the official textttplic analysis. The code is also described in Li et al. (in prep). Each page is directly generated from a source file used in the pipeline, in the style of Literate programming. Each source file can be located on the PSPipe GitHub using the Edit on GitHub link on the top of every page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"All executed code within a pipeline component is displayed in light orange code blocks.\nComments in the pipeline components are rendered as markdown.\nThe rendered pages are run on low-resolution Planck 2018 half-mission maps and masks at 143 GHz, generated by averaging down to n_mathrmside = 256.\nAt the top of each page, we provide examples for how to run the pipeline component on the Planck data.\nFor the full analysis described in Li et al. (in prep), consult the pages on Slurm files and cluster use.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The map/alm handling routines for this project were contributed into the Healpix.jl package, and the mode-coupling and covariance matrix calculations were added to PowerSpectra.jl. This pipeline mostly wrangles data and calls the routines from those packages.","category":"page"},{"location":"#Package-Installation","page":"Introduction","title":"Package Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We use the package manager in the Julia interpeter to install the latest versions of Healpix and PowerSpectra. This will be simpler in the future, when we tag a stable version of these packages for the General Registry.  For now, we add the latest versions of these packages from GitHub. Note that package  installation requires an internet connection, so unlike the other parts of the pipeline, setup.jl requires an internet connection. If you're on a cluster, that means you need  to run this file on the head node in order to install packages.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<pre class=\"shell\">\n<code class=\"language-julia hljs\">using Pkg  \nPkg.add(PackageSpec(name=\"Healpix\", rev=\"master\")) \nPkg.add(url=\"git@github.com:xzackli/PowerSpectra.jl.git\")\nPkg.add([\"CSV\", \"DataFrames\", \"TOML\", \"BlackBoxOptim\", \"FileIO\", \"JLD2\"])\n</code></pre>","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/src/setup.jl\"","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"# all examples are run on an example global.toml and downsized maps.\nARGS = [\"example.toml\"]","category":"page"},{"location":"setup/#Setup-(setup.jl)","page":"setup.jl","title":"Setup (setup.jl)","text":"","category":"section"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"This pipeline is written in Julia, so you will need a Julia installation in order to run the components. We recommend you use the precompiled binaries provided on the Julia website. Make sure to add the Julia executable to your path, as described in the platform-specific instructions.","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"The command-line interface for this basic pipeline setup script is","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"<pre class=\"shell\">\n<code class=\"language-shell hljs\">$ julia setup.jl global.toml</code></pre>","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"It displays the contents of the global TOML configuration file named global.toml.\nThis script downloads the Planck data to the specified directories in global.toml.","category":"page"},{"location":"setup/#Configuration","page":"setup.jl","title":"Configuration","text":"","category":"section"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"All of the pipeline scripts take a configuration TOML file as the first argument. We now print out just the [dir] entry in the TOML, which is what you will need to configure.","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"using TOML\nconfigfile = ARGS[1]  # read in the first command line argument\nprintln(\"config filename: \", configfile, \"\\n\")\n\n# take a look at the config\nconfig = TOML.parsefile(configfile)\nTOML.print(Dict(\"dir\"=>config[\"dir\"]))  # print just the \"dir\" TOML entry","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"The scratch space is where intermediary files are deposited.\nNote that each map file has an identifier. This shortens the long names, but more importantly allows one to set up a custom system of names when we cross-correlate Planck with other experiments.\nIn this case, we preface all Planck maps and masks with P, and include the frequency and split.","category":"page"},{"location":"setup/#Downloading-the-Planck-2018-Data","page":"setup.jl","title":"Downloading the Planck 2018 Data","text":"","category":"section"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"# set up download urls\nusing Downloads\n\nif length(ARGS) == 0\n    TARGET_DIR = pwd()\nelse\n    TARGET_DIR = ARGS[1]\nend\n\n# set up directories\nmapdest = config[\"dir\"][\"map\"]\nmaskdest = config[\"dir\"][\"mask\"]\nbeamdest = config[\"dir\"][\"beam\"]\nmkpath(mapdest)\nmkpath(maskdest)\nmkpath(beamdest)\n\nfunction download_if_necessary(url, dest; verbose=true)\n    if isfile(dest) == false\n        verbose && println(\"Downloading \", dest)\n        @time Downloads.download(url, dest)\n    else\n        verbose && println(\"Extant, skip \", dest)\n    end\nend","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"# now read from config and then actually download\nmapfiles = values(config[\"map\"])\nmaskfiles = [values(config[\"maskT\"])..., values(config[\"maskP\"])...]\n\nfor f in mapfiles\n    download_if_necessary(joinpath(config[\"url\"][\"maps\"], f), joinpath(mapdest, f))\nend\n\nfor f in maskfiles\n    download_if_necessary(joinpath(config[\"url\"][\"masks\"], f), joinpath(maskdest, f))\nend\n\n# just download beamfile to the target directory base.\nbeamfile = \"HFI_RIMO_BEAMS_R3.01.tar.gz\"\nfullbeamfile = joinpath(beamdest, beamfile)\ndownload_if_necessary(joinpath(config[\"url\"][\"beams\"], beamfile), fullbeamfile)\nrun(`cp $(fullbeamfile) $(joinpath(beamdest, \"tempbeamgz\"))`)\nrun(`gzip -f -d $(joinpath(beamdest, beamfile))`)\nrun(`mv $(joinpath(beamdest, \"tempbeamgz\")) $(fullbeamfile)`)\nbeamfiletar = replace(beamfile, \".tar.gz\"=>\".tar\")\nrun(`tar -xf $(joinpath(beamdest, beamfiletar)) --overwrite -C $(beamdest)`);\nnothing #hide","category":"page"},{"location":"setup/","page":"setup.jl","title":"setup.jl","text":"# We also want to retrieve the plic templates.\nplicrefdir = joinpath(config[\"dir\"][\"scratch\"])\nplicreffile = joinpath(config[\"dir\"][\"scratch\"], \"plicref.tar.gz\")\ndownload_if_necessary(\n    \"https://github.com/xzackli/PSPipePlanckRender.jl/releases/download/0.1.2/plicref.tar.gz\",\n    plicreffile)\nrun(`tar -xzvf $(plicreffile) --overwrite -C $(plicrefdir)`);\nnothing #hide","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"EditURL = \"https://github.com/simonsobs/PSpipe/tree/planckcov/project/Planck_cov/src/util.jl\"","category":"page"},{"location":"util/#Utilities","page":"util.jl","title":"Utilities","text":"","category":"section"},{"location":"util/","page":"util.jl","title":"util.jl","text":"Unlike every other file in the pipeline, this file is not intended to be run directly. Instead, include this in other files. These utilities provide an interface to the Planck data products, namely","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"binning matrix\nbeam W_ell^XY = B_ell^X B_ell^Y\nforeground model cross-spectra\ntextttplic reference covariance matrix and reference spectra, for comparison plots","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"using PowerSpectra\nusing DataFrames, CSV\nusing DelimitedFiles\nusing LinearAlgebra","category":"page"},{"location":"util/#Planck-Binning","page":"util.jl","title":"Planck Binning","text":"","category":"section"},{"location":"util/","page":"util.jl","title":"util.jl","text":"Planck bins the spectra at the very end, and applies an ell (ell+1) relative weighting inside the bin. This utility function generates the binning operator P_bell such that C_b = P_b ell C_ell. It also returns the mean of the left and right bin edges, which is what is used when plotting the Planck spectra.","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"\"\"\"\n    util_planck_binning(binfile; lmax=6143)\n\nObtain the Planck binning scheme.\n\n### Arguments:\n- `binfile::String`: filename of the Planck binning, containing left/right bin edges\n\n### Keywords\n- `lmax::Int=6143`: maximum multipole for one dimension of the binning matrix\n\n### Returns:\n- `Tuple{Matrix{Float64}, Vector{Float64}`: returns (binning matrix, bin centers)\n\"\"\"\nfunction util_planck_binning(binfile; lmax=6143)\n    bin_df = DataFrame(CSV.File(binfile;\n        header=false, delim=\" \", ignorerepeated=true))\n    lb = (bin_df[:,1] .+ bin_df[:,2]) ./ 2\n    P = binning_matrix(bin_df[:,1], bin_df[:,2], ‚Ñì -> ‚Ñì*(‚Ñì+1) / (2œÄ); lmax=lmax)\n    return P, lb[1:size(P,1)]\nend","category":"page"},{"location":"util/#Planck-Beam","page":"util.jl","title":"Planck Beam","text":"","category":"section"},{"location":"util/","page":"util.jl","title":"util.jl","text":"The Planck effective beams are azimuthally-averaged window functions induced by the instrumental optics. This utility function reads the Planck beams from the RIMO, which are of the form TT_2_TT, TT_2_EE etc. Conventionally, the Planck spectra are stored with the diagonal of the beam-mixing matrix applied.","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"C_ell = W^-1_ell hatC_ell","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"\"\"\"\n    util_planck_beam_Wl([T::Type=Float64], freq1, split1, freq2, split2, spec1_, spec2_;\n        lmax=4000, beamdir=nothing)\n\nReturns the Planck beam transfer of [spec1]_to_[spec2], in Wl form.\n\n### Arguments:\n- `T::Type=Float64`: optional first parameter specifying numerical type\n- `freq1::String`: frequency of first field\n- `split1::String`: split of first field (i.e. hm1)\n- `freq2::String`: frequency of first field\n- `split2::String`: split of second field (i.e. hm2)\n- `spec1_`: converted to string, source spectrum like TT\n- `spec2_`: converted to string, destination spectrum\n\n### Keywords\n- `lmax=4000`: maximum multipole\n- `beamdir=nothing`: directory containing beam FITS files. if nothing, will fall back to\n        the PowerSpectra.jl beam files.\n\n### Returns:\n- `SpectralVector`: the beam Wl, indexed 0:lmax\n\"\"\"\nfunction util_planck_beam_Wl(T::Type, freq1, split1, freq2, split2, spec1_, spec2_;\n                        lmax=4000, beamdir=nothing)\n    if isnothing(beamdir)\n        @warn \"beam directory not specified. switching to PowerSpectra.jl fallback\"\n        beamdir = PowerSpectra.planck256_beamdir()\n    end\n    spec1 = String(spec1_)\n    spec2 = String(spec2_)\n\n    if parse(Int, freq1) > parse(Int, freq2)\n        freq1, freq2 = freq2, freq1\n        split1, split2 = split2, split1\n    end\n    if (parse(Int, freq1) == parse(Int, freq2)) && ((split1 == \"hm2\") && (split1 == \"hm1\"))\n        split1, split2 = split2, split1\n    end\n\n    fname = \"Wl_R3.01_plikmask_$(freq1)$(split1)x$(freq2)$(split2).fits\"\n    f = PowerSpectra.FITS(joinpath(beamdir, \"BeamWf_HFI_R3.01\", fname))\n    Wl = convert(Vector{T}, read(f[spec1], \"$(spec1)_2_$(spec2)\")[:,1])\n    if lmax < 4000\n        Wl = Wl[1:lmax+1]\n    else\n        Wl = vcat(Wl, last(Wl) * ones(T, lmax - 4000))\n    end\n    return SpectralVector(Wl)\nend\nutil_planck_beam_Wl(T::Type, freq1, split1, freq2, split2, spec1; kwargs...) =\n    util_planck_beam_Wl(T, freq1, split1, freq2, split2, spec1, spec1; kwargs...)\nutil_planck_beam_Wl(freq1::String, split1, freq2, split2, spec1, spec2; kwargs...) =\n    util_planck_beam_Wl(Float64, freq1, split1, freq2, split2, spec1, spec2; kwargs...)","category":"page"},{"location":"util/#Planck-Likelihood-Specifics","page":"util.jl","title":"Planck Likelihood Specifics","text":"","category":"section"},{"location":"util/","page":"util.jl","title":"util.jl","text":"The Planck likelihood uses a specific choice of spectra and multipole ranges for those spectra. We provide some utility functions to retrieve a copy of the spectra order and the multipole minimum and maximum for those spectra.","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"plic_order() = (\n    (:TT,\"100\",\"100\"), (:TT,\"143\",\"143\"), (:TT,\"143\",\"217\"), (:TT,\"217\",\"217\"),\n    (:EE,\"100\",\"100\"), (:EE,\"100\",\"143\"), (:EE,\"100\",\"217\"), (:EE,\"143\",\"143\"),\n    (:EE,\"143\",\"217\"), (:EE,\"217\",\"217\"),\n    (:TE,\"100\",\"100\"), (:TE,\"100\",\"143\"), (:TE,\"100\",\"217\"), (:TE,\"143\",\"143\"),\n    (:TE,\"143\",\"217\"), (:TE,\"217\",\"217\"))\n\nplic_ellranges() = Dict(\n    (:TT, \"100\", \"100\") => (30, 1197),\n    (:TT, \"143\", \"143\") => (30, 1996),\n    (:TT, \"143\", \"217\") => (30, 2508),\n    (:TT, \"217\", \"217\") => (30, 2508),\n    (:EE, \"100\", \"100\") => (30, 999),\n    (:EE, \"100\", \"143\") => (30, 999),\n    (:EE, \"100\", \"217\") => (505, 999),\n    (:EE, \"143\", \"143\") => (30, 1996),\n    (:EE, \"143\", \"217\") => (505, 1996),\n    (:EE, \"217\", \"217\") => (505, 1996),\n    (:TE, \"100\", \"100\") => (30, 999),\n    (:TE, \"100\", \"143\") => (30, 999),\n    (:TE, \"100\", \"217\") => (505, 999),\n    (:TE, \"143\", \"143\") => (30, 1996),\n    (:TE, \"143\", \"217\") => (505, 1996),\n    (:TE, \"217\", \"217\") => (505, 1996))","category":"page"},{"location":"util/#Signal-Spectra","page":"util.jl","title":"Signal Spectra","text":"","category":"section"},{"location":"util/","page":"util.jl","title":"util.jl","text":"The covariance matrix calculation and and signal simulations require an assumed signal spectra. We use the same foreground spectra as used in the textplic likelihood. This returns dictionaries for signal and theory C_ell in mumathrmK between two frequencies. The data is stored in the plicref directory in the config.","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"function signal_and_theory(freq1, freq2, config::Dict)\n    likelihood_data_dir = joinpath(config[\"dir\"][\"scratch\"], \"plicref\")\n    th = read_commented_header(joinpath(likelihood_data_dir,\"theory_cl.txt\"))\n    fg = read_commented_header(joinpath(likelihood_data_dir,\n        \"base_plikHM_TTTEEE_lowl_lowE_lensing.minimum.plik_foregrounds\"))\n\n    ranges = plic_ellranges()\n    for (spec, f1, f2) in plic_order()\n        lmin, lmax = ranges[spec, f1, f2]\n        const_val = fg[lmax-1,\"$(spec)$(f1)X$(f2)\"]\n        # constant foreground level after lmax -- there are fitting artifacts otherwise\n        fg[(lmax-1):end, \"$(spec)$(f1)X$(f2)\"] .= const_val\n    end\n\n    # loop over spectra and also fill in the flipped name\n    freqs = (\"100\", \"143\", \"217\")\n    specs = (\"TT\", \"TE\", \"ET\", \"EE\")\n    for f1 in freqs, f2 in freqs, spec in specs\n        if \"$(spec)$(f1)X$(f2)\" ‚àâ names(fg)\n            if \"$(reverse(spec))$(f2)X$(f1)\" ‚àà names(fg)\n                fg[!, \"$(spec)$(f1)X$(f2)\"] = fg[!, \"$(reverse(spec))$(f2)X$(f1)\"]\n            else\n                fg[!, \"$(spec)$(f1)X$(f2)\"] = zeros(nrow(fg))\n            end\n        end\n    end\n\n    ap(v) = vcat([0., 0.], v)\n    ell_fac = fg[!, \"l\"] .* (fg[!, \"l\"] .+ 1) ./ (2œÄ);\n    signal_dict = Dict{String,Vector{Float64}}()\n    theory_dict = Dict{String,Vector{Float64}}()\n\n    for XY‚ÇÄ in specs  ## XY‚ÇÄ is the spectrum to store\n        f‚ÇÅ, f‚ÇÇ = parse(Int, freq1), parse(Int, freq2)\n        if f‚ÇÅ <= f‚ÇÇ\n            XY = XY‚ÇÄ\n        else  ## swap what we're looking for, as fg data only has those cross-spectra\n            XY = XY‚ÇÄ[2] * XY‚ÇÄ[1]\n            f‚ÇÅ, f‚ÇÇ = f‚ÇÇ, f‚ÇÅ\n        end\n        if XY == \"ET\"\n            theory_cl_XY = th[!, \"TE\"] ./ (th[!, \"L\"] .* (th[!, \"L\"] .+ 1) ./ (2œÄ))\n        else\n            theory_cl_XY = th[!, XY] ./ (th[!, \"L\"] .* (th[!, \"L\"] .+ 1) ./ (2œÄ))\n        end\n        fg_cl_XY = fg[!, \"$(XY)$(f‚ÇÅ)X$(f‚ÇÇ)\"] ./ (fg[!, \"l\"] .* (fg[!, \"l\"] .+ 1) ./ (2œÄ))\n\n        signal_dict[XY‚ÇÄ] =  ap(theory_cl_XY .+ fg_cl_XY[1:2507])\n        theory_dict[XY‚ÇÄ] =  ap(theory_cl_XY)\n    end\n    return signal_dict, theory_dict\nend","category":"page"},{"location":"util/#Planck-\\texttt{plic}-Reference","page":"util.jl","title":"Planck textttplic Reference","text":"","category":"section"},{"location":"util/","page":"util.jl","title":"util.jl","text":"In various parts of the pipeline, we want to compare our results to the official 2018 data release. These routines load them from disk. They're automatically downloaded to the plicref directory specified in the configuration TOML.","category":"page"},{"location":"util/","page":"util.jl","title":"util.jl","text":"\"\"\"\n    PlanckReferenceCov(plicrefpath::String)\n\nStores the spectra and covariances of the reference plic analysis.\n\"\"\"\nPlanckReferenceCov\n\nstruct PlanckReferenceCov{T}\n    cov::Array{T,2}\n    ells::Vector{Int}\n    cls::Vector{T}\n    keys::Vector{String}\n    sub_indices::Vector{Int}\n    key_index_dict::Dict{String,Int}\nend\n\nfunction PlanckReferenceCov(plicrefpath)\n    ellspath = joinpath(plicrefpath, \"vec_all_spectra.dat\")\n    clpath = joinpath(plicrefpath, \"data_extracted.dat\")\n    covpath = joinpath(plicrefpath, \"covmat.dat\")\n    keys = [\"TT_100x100\", \"TT_143x143\", \"TT_143x217\", \"TT_217x217\", \"EE_100x100\",\n        \"EE_100x143\", \"EE_100x217\", \"EE_143x143\", \"EE_143x217\", \"EE_217x217\", \"TE_100x100\",\n        \"TE_100x143\", \"TE_100x217\", \"TE_143x143\", \"TE_143x217\", \"TE_217x217\"]\n    cov = inv(readdlm(covpath))\n    ells = readdlm(ellspath)[:,1]\n    cls = readdlm(clpath)[:,2]\n\n    subarray_indices = collect(0:(size(cov,1)-2))[findall(diff(ells) .< 0) .+ 1] .+ 1\n    sub_indices = [1, subarray_indices..., length(cls)+1]\n    key_ind = 1:length(keys)\n    key_index_dict = Dict(keys .=> key_ind)\n\n    return PlanckReferenceCov{Float64}(cov, ells, cls, keys, sub_indices, key_index_dict)\nend\n\n\n\"\"\"\n    get_subcov(pl::PlanckReferenceCov, spec1, spec2)\n\nExtract the sub-covariance matrix corresponding to spec1 √ó spec2.\n\n### Arguments:\n- `pl::PlanckReferenceCov`: data structure storing reference covmat and spectra\n- `spec1::String`: spectrum of form i.e. \"TT_100x100\"\n- `spec2::String`: spectrum of form i.e. \"TT_100x100\"\n\n### Returns:\n- `Matrix{Float64}`: subcovariance matrix\n\"\"\"\nfunction get_subcov(pl::PlanckReferenceCov, spec1, spec2)\n    i = pl.key_index_dict[spec1]\n    j = pl.key_index_dict[spec2]\n    return pl.cov[\n        pl.sub_indices[i] : (pl.sub_indices[i + 1] - 1),\n        pl.sub_indices[j] : (pl.sub_indices[j + 1] - 1),\n    ]\nend\n\n\"\"\"\n    extract_spec_and_cov(pl::PlanckReferenceCov, spec1)\n\nExtract the reference ells, cl, errorbar, and sub-covariance block for a spectrum √ó itself.\n\n### Arguments:\n- `pl::PlanckReferenceCov`: data structure storing reference covmat and spectra\n- `spec1::String`: spectrum of form i.e. \"TT_100x100\"\n\n### Returns:\n- `(ells, cl, err, this_subcov)`\n\"\"\"\nfunction extract_spec_and_cov(pl::PlanckReferenceCov, spec1)\n    i = pl.key_index_dict[spec1]\n    this_subcov = get_subcov(pl, spec1, spec1)\n    ells = pl.ells[pl.sub_indices[i]:(pl.sub_indices[i + 1] - 1)]\n    cl = pl.cls[pl.sub_indices[i]:(pl.sub_indices[i + 1] - 1)]\n    err = sqrt.(diag(this_subcov))\n    return ells, cl, err, this_subcov\nend","category":"page"}]
}
